* Definition of generic words
- Generic word has =def>>= slot which contains quotation to a call to =mega-cache-lookup=.
- This definition quotation is called when passed to the non-optimizing compiler
  non-optimizing compiler and thus the =mega-cache-lookup= call is encountered
  in =quotation_jit::iterate_quotation=, which compiles in a primitive call via
  =emit_mega_cache_lookup=:
  - emits a call to =PIC-LOAD= (which I think is the PIC call stub, and in the
    default implementation simply gets the dispatch#-th argument from the stack)
  - emits a call to =MEGA-LOOKUP=.  At this point, if there was a cache hit,
    the following instructions are not executed
  - emits a stack frame for:
    - push method table
    - push dispatch#
    - push the cache
    - a call to the miss word, which ends up in =primitve_megacache_lookup=

* TODO PIC
- two types of caches: =PIC_TAG= and =PIC_TUPLE=, the type is determined by
  cache contents alone in =determine_inline_cache_type=.  A cold cache starts
  out as =PIC_TAG= cache.
** =PIC_TAG= Inline Cache
- contains jit-compiled successive checks =PIC_CHECK_TAG= which compare the loaded thing
  (=PIC_LOAD=) with the cache entry keys by simply comparing the object's tag.
** =PIC_TUPLE= Inline Cache
- instead of checking the tag, this generates code to CMP the two registers
  containing the loaded object and the cache entry key.
** TODO Difference
It seems like the difference is that the TAG check performs an immediate
comparison, while the tuple check has to perform an additional load???

I think the idea is that if dispatch is done only on built-in classes, the tag
comparison is sufficient, while in the case of tuple classes, the pointer to the
layout has to be compared?

The object to check itself is encoded as tagged object.  If comparing e.g.
fixnums, then the tag must be compared.  If it is a tuple, the value part of the
object is a pointer to the layout.  Thus, when comparing tuple classes, the
layout field of the class has to be fetched for comparison.

??? But does that not mean that if the cache type is set to =PIC_TUPLE=, a
fixnum could then never be a hit? (or only if it is the exact number?)

* Compilation of generic word calls
** Non-optimizing compiler
*** Generic word definition
- The generic word has been defined with the =pic-def>>= and =pic-tail-def>>=
  slots which contain factor code defining the inline cache stubs.  These are of
  the form =[ \ word { ... dispatch-table ... } dispatch# { } inline-cache-miss ]=
- When finishing a compilation unit, the word is passed to =recompile=.  Since
  it is not to be optimized, the quotation will be passed to =modify-code-heap=,
  i.e. =primitive_modify_code_heap=, which will invoke =jit_compile_word=
- Like for regular words, the =def>>= quotation is jit-compiled via
  =jit_compile_quotation=
- Additionally, the same thing is done to the =pic-def>>= and =pic-tail-def>>=
  slots for the generic word
*** Generic word call site
- =primitive_modify_code_heap= → =update_code_heap_words= →
  =update_word_references= is called on the complete code heap, which iterates
  over (TODD: what exactly???) some instruction-operands of a code-block, where
  it dispatches on a relocation type
- In addition to =RT_ENTRY_POINT=, which seems to compute and return the entry
  point of the thing being called, there is =RT_ENTRY_POINT_PIC= and
  =RT_ENTRY_POINT_PIC_TAIL=, which call =compute_entry_point_pic_{tail_}address=
- That in turn returns the entry point of the compiled code in the =pic-def>>= slot
- This can be seen via =disassemble= of a word containing a generic call site,
  which references the corresponding =pic-def= or =pic-tail-def= quotation.

* Lookup-Method procedure in VM,

Entry point: =lookup-method= primitive in =generic.single.private=, implemented
in vm as =primitive_lookup_method=.  Either called directly from code, or via a
mega-cache miss inside the VM

- pop methods dispatch table, and object, call =lookup_method(obj, methods)=
- =lookup_method=
  - Index the dispatch table by the object tag -> =method=
  - If =obj= is a tuple, call =lookup_tuple_method=, where =method= is the
    tuple dispatch array
  - Otherwise, return =method=
  - =lookup_tuple_method=
    - get the tuple =layout= from =obj=
    - untag the =methods= array as =echelons=
    - initialize echelon number =echelon= as
       =min(layout->echelon, length(echelons)-1)=, basically starting at the
      least-specific subclass.
    - While the root echelon has not been reached:
      - get the element at position =echelon= from =echelons= -> =echelon-methods=
      - if =echelon-methods= is a word, return it. (I think that means that the
        dispatch is delegated to a word, e.g. a predicate engine)
      - otherwise, if the entry is not =f=, it is a hash-table:
        - set =klass= to the nth superclass, which is at offset =2*echelon= in
          the layout
        - get the corresponding nth superclass =hashcode= (offset =2*echelon+1=
          in the layout)
        - perform a lookup in that hashtable via =search_lookup_hash=, which
          extracts the corresponding bucket via hash-code bit-masking.  If the
          element is an array, perform an alist-search for the =klass=,
          otherwise it was a non-ambiguous hit, so the element itself is the
          method. (Note: it seems that arrays are always used, even for
          non-ambiguous hits.  Note 2, )
      - If none of the above steps have returned, decrease =echelon= and repeat.
    - If nothing has been found at =echelon == 0=, the lookup failed.  This is
      an error.

* Modification for multiple dispatch lookup
The procedure described above performs a search for =klass= in the table, which
is a sequence of dispatch tables.  =echelon= is the index to which table is
current.  This can be interpreted as an automaton with state transfer and
lookup.  In this case, the transfer function will return the next upper echelon,
predicated on whether the correct result has been returned.

It should be possible by turning this into a state machine suitable for one of
the DFA lookup methods by augmenting it with a second element to return from the
element, which can be used as the selector for the next echelon table to test.

This will also include instructions on which class to test next.  This is
straightforward if we turn =klass= into an array, and the current test index
becomes part of the state.

This turns the whole thing into a simple automaton described by an array of
state transfer functions.

So far, I have seen two kinds of decision trees being used for that.  One is
based on class equality tests, the other is based on subtype tests.

** Class equality-based
Pros:
- Cheapest low-level test (pointer comparison).

Cons:
- Probably large overhead in creating the FSM
  - No subclass range comparisons means that there will probably be a lot of
    states (compared to subclass tests)
  - Every added subclass will probably always trigger more table recompilations

** Subclass-based
Pros and cons opposite to above.  Specifically, the subclass test is normally
quite expensive.  However, the echelon structure of two layouts should provide
that result in constant time.
