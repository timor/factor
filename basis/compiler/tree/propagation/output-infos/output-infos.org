* Output Value Information Propagation
** Problem: Compilation order for compilation unit
Currently:
1. Throw away all dependency information
2. Compile words in arbitrary order
3. If lucky, output info is available for a word currently being compiled

** Recursive compilation
While compiling a word, if a call has no output information, run the
compilation for the nested call(TODO: should that only be done for the words in
the current unit?  Theoretically, if everything has been compiled this way,
output info should be present.  Maybe warn if it is not in the current unit)  Keep a trace to make sure cycles are
broken.

If any cycles are detected, this means a mutually recursive dependency.
*** Built-in Recursion support
- Single recursion handling seems to be limited to inline recursive combinators
- Single recursion with calls to the word being defined don't seem to be turned
  into tail calls?

#+begin_src factor
  ! Test if this does any form of propagation

  TYPED: baz ( x: fixnum -- y )
      dup 0 > [ 1 - baz ] [ drop 42 ] if ;
#+end_src
- Will not be turned into tail calls
*** Inlining for type propagation at call sites
For single recursion:

- Observation: Whenever a branch is taken that has a recursive invocation, the
  return value of that branch can only be computed by a run of the word with
  that branch removed!
- This means, that for propagation, each call site must be inlined with the
  corresponding branch being eliminated.
- The complexity is linear for every branch containing a call site in the graph

*** Mutual Recursion

It should be possible to reduce the case for mutual recursion to this.  A nested
propagation trace could look like this: =foo -> bar -> baz -> foo=. This means
that, while compiling =foo=, we entered a cycle when getting the output info of bar.

**** Strategy 1: handle in the immediate caller

Continuation: Throw a condition to =baz=, that =baz= must be propagated inlining
=foo=.  This will cause =baz= to encounter the cycle when getting the output infos
of =bar=.
New Trace: =foo -> bar -> baz -> bar -> baz=.

Throw a condition to =bar=, that =bar= must be propagated inlining =baz=.

This will cause =bar= to encounter itself, triggering Single recursive compilation.

**** Strategy 2: handle in the detected cycle

Continuation:
- Return to propagation pass of foo with a list of functions to be inlined for propagation
- Create a modified tree which splices all of these functions (recursively,
  until the inline list is empty)
- Compile as if being single recursive above
