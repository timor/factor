* Output Value Information Propagation
** Problem: Compilation order for compilation unit
Currently:
1. Throw away all dependency information
2. Compile words in arbitrary order
3. If lucky, output info is available for a word currently being compiled

** Recursive compilation
While compiling a word, if a call has no output information, run the
compilation for the nested call(TODO: should that only be done for the words in
the current unit?  Theoretically, if everything has been compiled this way,
output info should be present.  Maybe warn if it is not in the current unit)  Keep a trace to make sure cycles are
broken.

If any cycles are detected, this means a mutually recursive dependency.
*** Built-in Recursion support
- Single recursion handling seems to be limited to inline recursive combinators
- Single recursion with calls to the word being defined don't seem to be turned
  into tail calls?

#+begin_src factor
  ! Test if this does any form of propagation

  TYPED: baz ( x: fixnum -- y )
      dup 0 > [ 1 - baz ] [ drop 42 ] if ;
#+end_src
- Will not be turned into tail calls
*** Inlining for type propagation at call sites
For single recursion:

- Observation: Whenever a branch is taken that has a recursive invocation, the
  return value of that branch can only be computed by a run of the word with
  that branch removed!
- This means, that for propagation, each call site must be inlined with the
  corresponding branch being eliminated.
- The complexity is linear for every branch containing a call site in the graph

*** Mutual Recursion

With nested compilation, it is possible to reduce the case for mutual recursion
to the one indicated above.  A nested
propagation trace could look like this: =foo -> bar -> baz -> foo=. This means
that, while compiling =foo=, we entered a cycle when getting the output info of bar.

In practice, this works like this:
When recompiling a list of words:
1. Store set of words into =recompile-set=
2. For each word:
   1. Check if word has been compiled by a nested compilation.  If yes, do
      nothing.  Else:
   2. Add current word to the nested compilation trace =nested-compilations=
   3. During propagation, for each =#call= node
      1. Inlining:
         1. If the call is to the current word, perform propagation on the inlined
            pruned body as described above, else:
         2. If the call is to one of the words in =nested-compilations=, This means
            we are encountering a dependency cycle during nested compilation.
            Perform propagation on the inlined body of the =#call='s word.
      2. Output Value Infos:
         1. Check for ="output-infos"= of the word being called, if there are none:
            1. Is the word being called in the =recompile-set=?
               1. If yes, throw a =nested-compilation-cycle= error
               2. If no, start nested compilation at 2.2
            2. If the word is not in the =recompile-set=, use
               =default-output-value-infos=.  (Alternatively, nested compilation
               could be triggered, recompiling words outside =recompile-set=)
   4. Return from nested compilation.  Leaving the scope introduced by 2.3.


Vj
Continuation: Throw a condition to =baz=, that =baz= must be propagated inlining
=foo=.  This will cause =baz= to encounter the cycle when getting the output infos
of =bar=.
New Trace: =foo -> bar -> baz -> bar -> baz=.


This will cause =bar= to encounter itself, triggering Single recursive compilation.

The implementation works like this:
- during compilation of =baz=, while trying to trigger

# **** Strategy 2: handle in the detected cycle

# Continuation:
# - Return to propagation pass of foo with a list of functions to be inlined for propagation
# - Create a modified tree which splices all of these functions (recursively,
#   until the inline list is empty)
# - Compile as if being single recursive above
