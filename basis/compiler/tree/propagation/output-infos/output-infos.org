* Output Value Information Propagation
** Problem: Compilation order for compilation unit
Currently:
1. Throw away all dependency information
2. Compile words in arbitrary order
3. If lucky, output info is available for a word currently being compiled

** Recursive compilation
While compiling a word, if a call has no output information, run the
compilation for the nested call(TODO: should that only be done for the words in
the current unit?  Theoretically, if everything has been compiled this way,
output info should be present.  Maybe warn if it is not in the current unit)  Keep a trace to make sure cycles are
broken.

If any cycles are detected, this means a mutually recursive dependency.
*** Built-in Recursion support
- Single recursion handling seems to be limited to inline recursive combinators
- Single recursion with calls to the word being defined don't seem to be turned
  into tail calls?

#+begin_src factor
  ! Test if this does any form of propagation

  TYPED: baz ( x: fixnum -- y )
      dup 0 > [ 1 - baz ] [ drop 42 ] if ;
#+end_src
- Will not be turned into tail calls
*** Inlining for type propagation at call sites
For single recursion:

- Observation: Whenever a branch is taken that has a recursive invocation, the
  return value of that branch can only be computed by a run of the word with
  that branch removed!
- This means, that for propagation, each call site must be inlined with the
  corresponding branch being eliminated.
- The complexity is linear for every branch containing a call site in the graph

*** Mutual Recursion

With nested compilation, it is possible to reduce the case for mutual recursion
to the one indicated above.  A nested
propagation trace could look like this: =foo -> bar -> baz -> foo=. This means
that, while compiling =foo=, we entered a cycle when getting the output info of bar.

In practice, this works like this:
When recompiling a list of words:
1. Store set of words into =recompile-set=
2. For each word:
   1. Check if word has been compiled by a nested compilation.  If yes, do
      nothing.  Else:
   2. Add current word to the nested compilation trace =nested-compilations=
   3. During propagation, for each =#call= node
      1. Inlining:
         1. If the call is to the current word, perform propagation on the inlined
            pruned body as described above, else:
         2. If the call is to one of the words in =nested-compilations=, This means
            we are encountering a dependency cycle during nested compilation.
            Perform propagation on the inlined body of the =#call='s word.
      2. Output Value Infos:
         1. Check for ="output-infos"= of the word being called, if there are none:
            1. Is the word being called in the =recompile-set=?
               1. If yes, throw a =nested-compilation-cycle= error
               2. If no, start nested compilation at 2.2
            2. If the word is not in the =recompile-set=, use
               =default-output-value-infos=.  (Alternatively, nested compilation
               could be triggered, recompiling words outside =recompile-set=)
   4. Return from nested compilation.  Leaving the scope introduced by 2.3.

*** Convergence
Observation: For tail-recursive cases, the propagated output value info should
always be correct:  If there is any kind of constraint/declaration at the
beginning of a word, it will also be there at every call site, so that the
inlined base cases will be propagated correctly.  If there was no constraint in
the preamble in the first place, then the output will be unconstrained either way.

This is different for non-tail-recursive words.  If there is any value info
growth after the return of a recursive call site, this growth is dependent on
the number of iterations, and assumed to be divergent.  The way this is checked
is that the output info, which results from recursive inline propagation at the
call site is not larger than that of the return value of the outer body after
propagation.   If it is, then the resulting value interval must be assumed to be
unbounded.

TODO: check if this is correct: The upper and the lower bound are independent in
that respect, though.

Implementation:
- When propagating an inlined recursive call site and removing any #branch
  nodes, make note of the corresponding #phi node, as well as which branches
  have been removed, store this information on a stack.
- Propagate the inlined pruned recursive tree
- Continue propagation in the outer tree.  When hitting the stored #phi node:
  - Check if the value info of the removed branches is less/equal than the one
    on the non-removed branches.  If not, open the interval to the corresponding side.
  - Remove the node from the stack
